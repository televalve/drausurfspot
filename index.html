<!DOCTYPE html><html lang='en' class=''>
<head>
<!--<script src='//static.codepen.io/assets/editor/live/console_runner-ce3034e6bde3912cc25f83cccb7caa2b0f976196f2f2d52303a462c826d54a73.js'></script>
<script src='//static.codepen.io/assets/editor/live/css_live_reload_init-890dc39bb89183d4642d58b1ae5376a0193342f9aed88ea04330dc14c8d52f55.js'>
</script><meta charset='UTF-8'><meta name="robots" content="noindex">
<link rel="shortcut icon" type="image/x-icon" href="//static.codepen.io/assets/favicon/favicon-8ea04875e70c4b0bb41da869e81236e54394d63638a1ef12fa558a4a835f1164.ico" />
<link rel="mask-icon" type="" href="//static.codepen.io/assets/favicon/logo-pin-f2d2b6d2c61838f7e76325261b7195c27224080bc099486ddd6dccb469b8e8e6.svg" color="#111" />
<link rel="canonical" href="https://codepen.io/hyuwah/pen/MyqqWb" />-->


<style class="cp-pen-styles"></style></head><body>
<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://code.highcharts.com/stock/highstock.js"></script>
    <script src="https://code.highcharts.com/modules/windbarb.js"></script>
    <script src="https://code.highcharts.com/stock/modules/exporting.js"></script>
    <!-- <script src="https://rawgithub.com/highslide-software/export-csv/master/export-csv.js"></script> -->

    <!-- Core JS -->
    <!-- <script src="./highchartsSG.js"></script> -->

    <!-- Materialize CSS Framework  -->
    <!-- Compiled and minified CSS   --> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.6/css/materialize.min.css">
    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.6/js/materialize.min.js"></script>

    <title>Drau Surfspot</title>
    
    
</head>

<body style="background-color: white;">
<header>
<center>
  <h4>Selkach Drau-Wetterstation</h4>
  <p></p>
  </center>
</header>

 <div id="header-container" style="height: 200px;margin: 0% 0% 0% 0%">

 </div>
 
 <div style="clear: left;margin: 0% 10% 0% 10%" id="below chart">
        
        <div class="row">
            <button class="btn waves-effect waves-light blue darken-3" value="km/h" name="km/h" onclick="setkmh();">km/h   
            </button>
            <button class="btn waves-effect waves-light blue darken-3" value="Knoten" name="Knoten" onclick="setknoten();">Knoten
            </button>
           <!-- <button class="btn waves-effect waves-light blue darken-3" value=" " name=" " onclick="loadOneChannel();"> </button> -->
            <!-- <input id="Update" name="Update" type="checkbox" /> -->
            <!-- <label for="Update" style="margin:0 8px">Update Charts (Latency)</label> -->
            
            <button style="float: right;" class="btn waves-effect waves-light blue darken-3" value="3" name="zoom3" onclick="setZoom(this);">Woche   
            </button>
            <button style="float: right;" class="btn waves-effect waves-light blue darken-3" value="2" name="zoom2" onclick="setZoom(this);">Tag   
            </button>
            <button style="float: right;" class="btn waves-effect waves-light blue darken-3" value="1" name="zoom1" onclick="setZoom(this);">12 Stunden   
            </button>
            <button style="float: right;" class="btn waves-effect waves-light blue darken-3" value="0" name="zoom0" onclick="setZoom(this);">3 Stunden   
            </button>

        </div>
 </div>
  
   <!-- <div class="row">
           <div class="input-field col s4">
            <select id="Channel Select">
              <option value="" disabled selected>Choose your option</option>
            </select>
          </div>
            <div class="input-field col s4">
            <select id="Loads">
                <option value="" disabled selected>Choose your option</option>
                <option value="1">1 Load</option>
                <option value="2">2 Loads</option>
            </select>
          </div>
        </div> -->

    <div id="chart-container" style="height: 450px;/*float:left; width:43% */;margin: 0% 10% 0% 10%">
        <div class="progress" style="margin:0% 0%">
            
            <div class="indeterminate"></div>
        </div>

    </div>
    
	<hr width="70%" align="center" noshade> 

    <div id="chartTemp-container" style="height: 450px;/*float:left; width:43% */;margin: 0% 10% 0% 10%">
    	<div class="progress" style="margin:0% 0%">
            
        	<div class="indeterminate"></div>
        </div>

    </div>
    
    <hr width="70%" align="center" noshade> 

    <div id="chartDebug-container" style="height: 450px;/*float:left; width:43% */;margin: 0% 10% 0% 10%">
    	<div class="progress" style="margin:0% 0%">
            
        	<div class="indeterminate"></div>
        </div>

    </div>
 

</body>

</html>

<!-- <script src='//static.codepen.io/assets/common/stopExecutionOnTimeout-b2a7b3fe212eaa732349046d8416e00a9dec26eb7fd347590fbced3ab38af52e.js'></script> -->
<script >// Webpage Javascript to chart multiple ThingSpeak channels on two axis with navigator, load historical data, and export cvs data.

// put your ThingSpeak Channel#, Channel Name, and API keys here.
// fieldList shows which field you want to load, and which axis to display that field on,
// the 'T' Temperature left axis, or the 'O' Other right axis.
var channelKeys = [];
//Change TO: display two fields from the same channel from a Rain gauge - 15min counts, and total counts
channelKeys.push({
    channelNumber: 276764, //Channel ID
    name: 'DSS',
    key: '',
    fieldList: [{
        field: 7,
        axis: 'km/h'
    }, {
        field: 1,
        axis: 'km/h'
    }, {
        field: 8,
        axis: '°'
    }]
});

var channelKeysTemp = [];
channelKeysTemp.push({
    channelNumber: 276764, //Channel ID
    name: 'DSS',
    key: '',
    fieldList: [{
        field: 4,
        axis: '°C'
    }, {
        field: 5,
        axis: 'hPa'
    }/*, {
        field: 6,
        axis: '%'
    }*/]
});

var channelKeysDebug = [];
channelKeysDebug.push({
    channelNumber: 289328, //Channel ID
    name: 'DSS Debug',
    key: '',
    fieldList: [{
        field: 4,
        axis: '%'
    }, {
        field: 6,
        axis: ''
    }/*, {
        field: 6,
        axis: '%'
    }*/]
});

var renderHeader = function () {
   $.getJSON('https://www.thingspeak.com/channels/' + channelKeys[0].channelNumber + '/feed.json?callback=?&amp;offset=0&amp;results=1;key=' + channelKeys[0].key, function(data) {
                // if no access
                if (data == '-1') {
                    window.console && console.log('Thingspeak Data Loading Error');
                }
                window.console && console.log('HEADER QUERY');

                var fieldStr = "data.feeds[0].field1";
            	var windspeed = eval(fieldStr);
            	fieldStr = "data.feeds[0].field7";
            	var windgust = eval(fieldStr);
            	fieldStr = "data.feeds[0].field4";
            	var temperatur = eval(fieldStr);
            	fieldStr = "data.feeds[0].field8";
            	var winddir = eval(fieldStr);
            	var date = getChartDate(data.feeds[0].created_at);

            	
				if(getCookie(isKnoten) == "1"){
					windspeed = windspeed * 0.539957; // convert to knots/knoten
					windgust = windgust * 0.539957; // convert to knots/knoten
				}

            	var ws = parseFloat(windspeed).toFixed(1); 
				var wg = parseFloat(windgust).toFixed(1);
				var tp = parseFloat(temperatur).toFixed(1);
				var wd = parseFloat(winddir).toFixed(1);
           // 	var template2 = '<h5>Windstärke: ' + ws + ' ' + getWindspeedUnit() + '</h5> <h5>Böe: ' + wg + ' ' + getWindspeedUnit() + '</h5> <h5>Windrichtung: ' + getWindDirName(wd) + '</h5> </h5> <h5>Temperatur: ' + tp + '°C </h5>';
				var template = '<div style="float:left; width:22%;margin: 0% 0% 0% 12%" > <font color="gray"> <h5>Windstärke </h5> </font> <h3>' + ws + ' ' + getWindspeedUnit() + '</h3> </div>' + 
							   '<div style="float:left; width:22%;margin: 0% 0% 0% 0%" >  <font color="gray"><h5>Böe </h5> </font> <h3>' + wg + ' ' + getWindspeedUnit() + '</h3> </div>' + 
							   '<div style="float:left; width:10%;margin: 0% 0% 0% 0%" >  <font color="gray"><h5>Windrichtung </h5></font>  <h3>' + getWindDirName(wd) + ' </h3> </div>' + 
							   '<div style="float:left; width:3%;margin: 0% 7% 0% 0%; transform: rotate(' + wd + 'deg)" >  <font color="black"><h1>&#8681</h1></font> </div>' + 
							   '<div style="float:left; width:22%;margin: 0% 0% 0% 0%;" > <font color="gray"><h5>Temperatur	 </h5></font>  <h3>' + tp + '°C </h3> </div>' +
							   '<div style="float:left; width:50%;margin: 0% 0% 0% 12%" > <font color="gray"> <font size="5"> Letztes Update: ' + Highcharts.dateFormat('%H:%M:%S  - %a, %e %b, %Y', new Date(date))	+ '</font>  </div>';

			    document.querySelector('#header-container').innerHTML = template;            	
            })
            .fail(function() {
                alert('getJSON request failed! ');
            });
};
renderHeader();

//  The charting library is called HighStock.  It is awesome!  HighSoft, the owners say,
//   "Do you want to use Highstock for a personal or non-profit project? Then you can use Highchcarts for
//   free under the  Creative Commons Attribution-NonCommercial 3.0 License. "
// http://forum.arduino.cc/index.php?topic=213058.msg1560990#msg1560990
var dynamicChart;
var dynamicChartTemp;
var dynamicChartDebug;
var channelsLoaded = 0;


// user's timezone offset
var myOffset = new Date().getTimezoneOffset();
 
var isKnoten = "isKnoten";
if(getCookie(isKnoten) == ""){
	setCookie(isKnoten, "1");
}

var zoom = "zoom";
if(getCookie(zoom) == ""){
	setCookie(isKnoten, "0");
}

function setZoom(btn){
	if(getCookie(zoom) != btn.value){
		setCookie(zoom, btn.value);

		updateAllChannels();	
	}
}
    
function getNumPoints(){
	var level = getCookie(zoom);
	if(level == 0){
		return 20; 
	}
	else if(level == 1){
		return 75;
	}
	else if(level == 2){
		return 130;
	}
	else if(level == 3){
		return 900;
	}
}

function getSkipPoints(){
	var level = getCookie(zoom);
	if(level == 0){
		return 1; 
	}
	else if(level == 1){
		return 2;
	}
	else if(level == 2){
		return 3;
	}
	else if(level == 3){
		return 20;
	}
}

function getWindspeedUnit(){
	if(getCookie(isKnoten) == "1"){
		return "Knoten";
	}
	else{
		return "km/h";

	}
}

// converts date format from JSON
function getChartDate(d) {
    // get the data using javascript's date object (year, month, day, hour, minute, second)
    // months in javascript start at 0, so remember to subtract 1 when specifying the month
    // offset in minutes is converted to milliseconds and subtracted so that chart's x-axis is correct
    return Date.UTC(d.substring(0, 4), d.substring(5, 7) - 1, d.substring(8, 10), d.substring(11, 13), d.substring(14, 16), d.substring(17, 19)) - (myOffset * 60000);
}

function setknoten(){
	if(getCookie(isKnoten) == "0"){
		setCookie(isKnoten, "1");
		renderHeader();
		updateAllChannels();
	}
}

function setkmh(){
	if(getCookie(isKnoten) == "1"){
		setCookie(isKnoten, "0");
		renderHeader();
		updateAllChannels();
	}
}

function updateAllChannels(){
	for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
    	{
    		channelsLoaded = 0;
       	 	channelKeys[channelIndex].loaded = false;
       	 	loadThingSpeakChannel(channelIndex, channelKeys[channelIndex].channelNumber, channelKeys[channelIndex].key, channelKeys[channelIndex].fieldList, false, false, false);
    	}
	for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
    {
        channelKeysTemp[channelIndex].loaded = false;
        loadThingSpeakChannel(channelIndex, channelKeysTemp[channelIndex].channelNumber, channelKeysTemp[channelIndex].key, channelKeysTemp[channelIndex].fieldList, false, true, false);
    }
    for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
    {
        channelKeysDebug[channelIndex].loaded = false;
        loadThingSpeakChannel(channelIndex, channelKeysDebug[channelIndex].channelNumber, channelKeysDebug[channelIndex].key, channelKeysDebug[channelIndex].fieldList, false, false, true);
    }
}

function setCookie(cname, cvalue) {
   // var d = new Date();
   // d.setTime(d.getTime() + (exdays*24*60*60*1000));
    //var expires = "expires="+ d.toUTCString();
    document.cookie = cname + "=" + cvalue;// + ";" + expires + ";path=/";
}

function getCookie(cname) {
    var name = cname + "=";
    var decodedCookie = decodeURIComponent(document.cookie);
    var ca = decodedCookie.split(';');
    for(var i = 0; i <ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

function getWindDirName(angle){
	
	if(angle < 22.5)
		return "Nord";
	else if (angle < 45.0)
		return "Nordnordost";
	else if (angle < 67.5)
		return "Nordost";
	else if (angle < 90.0)
		return "Ostnordost";
	else if (angle < 112.5)
		return "Ost";
	else if (angle < 135.0)
		return "Ostsüdost";
	else if (angle < 157.5)
		return "Südost";
	else if (angle < 180.0)
		return "Südsüdost";
	else if (angle < 202.5)
		return "Süd";
	else if (angle < 225.0)
		return "Südsüdwest";
	else if (angle < 247.5)
		return "Südwest";
	else if (angle < 270.0)
		return "Westsüdwest";
	else if (angle < 292.5)
		return "West";
	else if (angle < 315.0)
		return "Westnordwest";
	else if (angle < 337.5)
		return "Nordwest";
	else if (angle < 360.0)
		return "Nordnordwest";
		
	return "";
}

function getShortWindDirName(angle){
	
	if(angle < 22.5)
		return "N";
	else if (angle < 45.0)
		return "NNO";
	else if (angle < 67.5)
		return "NO";
	else if (angle < 90.0)
		return "ONO";
	else if (angle < 112.5)
		return "O";
	else if (angle < 135.0)
		return "OSO";
	else if (angle < 157.5)
		return "SO";
	else if (angle < 180.0)
		return "SSO";
	else if (angle < 202.5)
		return "S";
	else if (angle < 225.0)
		return "SSW";
	else if (angle < 247.5)
		return "SW";
	else if (angle < 270.0)
		return "WSW";
	else if (angle < 292.5)
		return "W";
	else if (angle < 315.0)
		return "WNW";
	else if (angle < 337.5)
		return "NW";
	else if (angle < 360.0)
		return "NNW";
		
	return "";
}


// Hide all series, via 'Hide All' button.  Then user can click on serries name in legent to show series of interest.
/*function HideAll() {
   for (var index = 0; index < dynamicChart.series.length; index++) // iterate through each series
   {
       if (dynamicChart.series[index].name == 'Navigator')
           continue;
       dynamicChart.series[index].hide();
       //window.console && console.log('Series Number:',index,' Name:',dynamicChart.series[index].name);
   }
}*/
// Show all series, via 'Show All' button.  Then user can click on serries name in legend to show series of interest.
/*function ShowAll() {
   for (var index = 0; index < dynamicChart.series.length; index++) // iterate through each series
   {
       if (dynamicChart.series[index].name == 'Navigator')
           continue;
       dynamicChart.series[index].show();
       //window.console && console.log('Series Number:',index,' Name:',dynamicChart.series[index].name);
   }
}*/

function addChartSeries(){
	window.console && console.log('ADD CHART SERIES');

        // add all Channel data to the chart
        for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeys[channelIndex].fieldList.length; fieldIndex++) // add each field
            {
            
            	dynamicChart.series[fieldIndex].setData(channelKeys[channelIndex].fieldList[fieldIndex].data, false);
            
            	// if(fieldIndex == 0 || fieldIndex == 1){
//                 	window.console && console.log('Channel ' + channelIndex + ' field ' + fieldIndex);
//                 		chartOptions.series.push({
//                    	 	data: channelKeys[channelIndex].fieldList[fieldIndex].data,
//                    	 	index: channelKeys[channelIndex].fieldList[fieldIndex].series,
//                    	 	yAxis: channelKeys[channelIndex].fieldList[fieldIndex].axis,
//                    	 	//visible:false,
//                    	 	type:'spline',
//                    	 	name: channelKeys[channelIndex].fieldList[fieldIndex].name
//                 	});
//                 }
//                 else if(fieldIndex == 2){
//                 	window.console && console.log('Channel ' + channelIndex + ' field ' + fieldIndex);
//                 		chartOptions.series.push({
//                    	 	data: channelKeys[channelIndex].fieldList[fieldIndex].data,
//                    	 	index: channelKeys[channelIndex].fieldList[fieldIndex].series,
//                    	 	yAxis: channelKeys[channelIndex].fieldList[fieldIndex].axis,
//                    	 	//visible:false,
//                    	 	type:'windbarb',
//                    	 	showInLegend: true,
// 
// 
// //                    	 	marker:{
// //                    	 		radius: 3
// //                    	 	},
//                    	 	name: channelKeys[channelIndex].fieldList[fieldIndex].name
//                 	});
//                 }
            }
        }
        // set chart labels here so that decoding occurs properly
        //chartOptions.title.text = data.channel.name;
        //chartOptions.xAxis.title.text = 'Date';
}

function addChartSeriesTemp(){
	window.console && console.log('ADD CHART SERIES TEMP');

        // add all Channel data to the chart
        for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeysTemp[channelIndex].fieldList.length; fieldIndex++) // add each field
            {
            	dynamicChartTemp.series[fieldIndex].setData(channelKeysTemp[channelIndex].fieldList[fieldIndex].data, false);
            }
        }
}

function addChartSeriesDebug(){
	window.console && console.log('ADD CHART SERIES DEBUG');

        // add all Channel data to the chart
        for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeysDebug[channelIndex].fieldList.length; fieldIndex++) // add each field
            {
            	dynamicChartDebug.series[fieldIndex].setData(channelKeysDebug[channelIndex].fieldList[fieldIndex].data, false);
            }
        }
}

function addChartSeriesData(chartOptions){
			window.console && console.log('ADD CHART SERIES DATA');

        // add all Channel data to the chart
        for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeys[channelIndex].fieldList.length; fieldIndex++) // add each field
            {
            	if(fieldIndex == 0 || fieldIndex == 1){
                	window.console && console.log('Channel ' + channelIndex + ' field ' + fieldIndex);
                		chartOptions.series.push({
                   	 	data: channelKeys[channelIndex].fieldList[fieldIndex].data,
                   	 	index: channelKeys[channelIndex].fieldList[fieldIndex].series,
                   	 	yAxis: channelKeys[channelIndex].fieldList[fieldIndex].axis,
                   	 	//visible:false,
                   	 	type:'areaspline',
                   	 	name: channelKeys[channelIndex].fieldList[fieldIndex].name
                	});
                }
                else if(fieldIndex == 2){
                	window.console && console.log('Channel ' + channelIndex + ' field ' + fieldIndex);
                		chartOptions.series.push({
                   	 	data: channelKeys[channelIndex].fieldList[fieldIndex].data,
                   	 	index: channelKeys[channelIndex].fieldList[fieldIndex].series,
                   	 	yAxis: channelKeys[channelIndex].fieldList[fieldIndex].axis,
                   	 	//visible:false,
                   	 	type:'windbarb',
                   	 	showInLegend: true,
						vectorLength: 25,
//                    	 	marker:{
//                    	 		radius: 3
//                    	 	},
                   	 	name: channelKeys[channelIndex].fieldList[fieldIndex].name
                	});
                }
            }
        }
        // set chart labels here so that decoding occurs properly
        //chartOptions.title.text = data.channel.name;
        //chartOptions.xAxis.title.text = 'Date';
}

function addChartSeriesDataTemp(chartOptions){
	window.console && console.log('ADD CHART SERIES DATA TEMP');

        // add all Channel data to the chart
        for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeysTemp[channelIndex].fieldList.length; fieldIndex++) // add each field
            {
                	window.console && console.log('Channel ' + channelIndex + ' field ' + fieldIndex);
                		chartOptions.series.push({
                   	 	data: channelKeysTemp[channelIndex].fieldList[fieldIndex].data,
                   	 	index: channelKeysTemp[channelIndex].fieldList[fieldIndex].series,
                   	 	yAxis: fieldIndex,//channelKeysTemp[channelIndex].fieldList[fieldIndex].axis,
                   	 	//visible:false,
                   	 	type:'spline',
                   	 	name: channelKeysTemp[channelIndex].fieldList[fieldIndex].name
                	});
            }
        }
}

function addChartSeriesDataDebug(chartOptions){
	window.console && console.log('ADD CHART SERIES DATA DEBUG');

        // add all Channel data to the chart
        for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeysDebug[channelIndex].fieldList.length; fieldIndex++) // add each field
            {
                	window.console && console.log('Channel ' + channelIndex + ' field ' + fieldIndex);
                		chartOptions.series.push({
                   	 	data: channelKeysDebug[channelIndex].fieldList[fieldIndex].data,
                   	 	index: channelKeysDebug[channelIndex].fieldList[fieldIndex].series,
                   	 	yAxis: fieldIndex,//channelKeysTemp[channelIndex].fieldList[fieldIndex].axis,
                   	 	//visible:false,
                   	 	type:'spline',
                   	 	name: channelKeysDebug[channelIndex].fieldList[fieldIndex].name
                	});
            }
        }
}


  // load the most recent 2500 points (fast initial load) from a ThingSpeak channel into a data[] array and return the data[] array
function loadThingSpeakChannel(sentChannelIndex, channelNumber, key, sentFieldList, firstLoad, isTempChart, isDebugChart) {
    	window.console && console.log('LOAD TS CHANNEL');

        var fieldList = sentFieldList;
        var channelIndex = sentChannelIndex;
        // get the Channel data with a webservice call
        $.getJSON('https://www.thingspeak.com/channels/' + channelNumber + '/feed.json?callback=?&amp;offset=0&amp;results=' + getNumPoints() + ';key=' + key, function(data) {
                // if no access
                if (data == '-1') {
                    $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
                    window.console && console.log('Thingspeak Data Loading Error');
                }
                for (var fieldIndex = 0; fieldIndex < fieldList.length; fieldIndex++) // iterate through each field
                {
                	console.log('LOAD TS CHANNEL ' + fieldIndex + ' channIndex: ' + channelIndex + ' ' +  channelNumber + ' ' + isTempChart);
                    fieldList[fieldIndex].data = [];
                    
                    for (var h = 0; h < data.feeds.length; h++) // iterate through each feed (data point)
                    {
                        var p = [] //new Highcharts.Point();
                        var fieldStr = "data.feeds[" + h + "].field" + fieldList[fieldIndex].field;
                        var v = eval(fieldStr);
                        var addIt = true;
                        p[0] = getChartDate(data.feeds[h].created_at);
                        
                        if(fieldIndex == 2 && (!isTempChart && !isDebugChart)){ // windrichtung Böe
							if(!((h % getSkipPoints()) == 0)){
								addIt = false;
							}

  							p[1] = 1;
                        	p[2] = parseFloat(v);// + 180.0;
                        
                        }
                        else if((fieldIndex == 1 || fieldIndex == 0) && (!isTempChart && !isDebugChart)){ // windgeschwindigkeit & Böe
                        	if(getCookie(isKnoten) == "1"){
	                        	p[1] = parseFloat(v) * 0.539957; // convert to knots/knoten
	                        }
	                        else{
								p[1] = parseFloat(v);
	                        }
                        }
                        else{
                        	p[1] = parseFloat(v);
                        }
                      
                        // if a numerical value exists add it
                        if (!isNaN(parseInt(v)) && addIt) {
                            fieldList[fieldIndex].data.push(p);
                        }
                    }
                    fieldList[fieldIndex].name = eval("data.channel.field" + fieldList[fieldIndex].field);
                    window.console && console.log('getJSON field name:', fieldList[fieldIndex].name);
                    window.console && console.log('loaded numPoints: ', fieldList[fieldIndex].data.length);

                }


                // distinguish between wind and temperature chart
                if(isTempChart){
                  	channelKeysTemp[channelIndex].fieldList = fieldList;
                	channelKeysTemp[channelIndex].loaded = true; 
                }
                else if(isDebugChart){
                	channelKeysDebug[channelIndex].fieldList = fieldList;
                	channelKeysDebug[channelIndex].loaded = true;
                }
                else {
                	channelKeys[channelIndex].fieldList = fieldList;
                	channelKeys[channelIndex].loaded = true;
                }
                
                channelsLoaded++;
                window.console && console.log('channels Loaded:', channelsLoaded);
                window.console && console.log('channel index:', channelIndex);
                
                if (channelsLoaded == (channelKeys.length+channelKeysTemp.length+channelKeysDebug.length) && firstLoad == true) {
                  Highcharts.setOptions({lang:{weekdays:["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]}}); 
	                  createChart();
                  	  createChartTemp();
					  createChartDebug();
                }
                else if (!firstLoad){
                	if(isTempChart){
                		addChartSeriesTemp();
                       	dynamicChartTemp.redraw();
                    }
                    else if (isDebugChart){
                    	addChartSeriesDebug();
                       	dynamicChartDebug.redraw();
                	}
                	else{
                       	addChartSeries();
                       	dynamicChart.redraw();
                	}
				}
            })
            .fail(function() {
                alert('getJSON request failed! ');
            });
    }

    // create the chart when all data is loaded
function createChart() {
    	window.console && console.log('CREATE CHART');

        // specify the chart options
        var chartOptions = {
            chart: {
                type: 'areaspline',
                renderTo: 'chart-container',
                zoomType: 'x'
                /*events: {
                    load: function() {
                        if ('true' === 'true' && (''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1)) {
                            // If the update checkbox is checked, get latest data every 15 seconds and add it to the chart
                            setInterval(function() {
                                if (document.getElementById("Update").checked) {
                                    for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
                                    {
                                        (function(channelIndex) {
                                            // get the data with a webservice call
                                            $.getJSON('https://www.thingspeak.com/channels/' + channelKeys[channelIndex].channelNumber + '/feed/last.json?callback=?&amp;offset=0&amp;location=false;key=' +
                                                channelKeys[channelIndex].key,
                                                function(data) {
                                                    for (var fieldIndex = 0; fieldIndex < channelKeys[channelIndex].fieldList.length; fieldIndex++) {
                                                        // if data exists
                                                        var fieldStr = "data.field" + channelKeys[channelIndex].fieldList[fieldIndex].field;
                                                        var chartSeriesIndex = channelKeys[channelIndex].fieldList[fieldIndex].series;
                                                        if (data && eval(fieldStr)) {
                                                            var p = [] //new Highcharts.Point();
                                                            var v = eval(fieldStr);
                                                            p[0] = getChartDate(data.created_at);
                                                            p[1] = parseFloat(v);
                                                            // get the last date if possible
                                                            if (dynamicChart.series[chartSeriesIndex].data.length > 0) {
                                                                last_date = dynamicChart.series[chartSeriesIndex].data[dynamicChart.series[chartSeriesIndex].data.length - 1].x;
                                                            }
                                                            var shift = false; //default for shift
                                                            // if a numerical value exists and it is a new date, add it
                                                            if (!isNaN(parseInt(v)) && (p[0] != last_date)) {
                                                                dynamicChart.series[chartSeriesIndex].addPoint(p, true, shift);
                                                            }
                                                        }
                                                        //window.console && console.log('channelKeys:',channelKeys);
                                                        //window.console && console.log('chartSeriesIndex:',chartSeriesIndex);
                                                        //window.console && console.log('channel index:',channelIndex);
                                                        //window.console && console.log('field index:',fieldIndex);
                                                        //window.console && console.log('update series name:',dynamicChart.series[chartSeriesName].name);
                                                        //window.console && console.log('channel keys name:',channelKeys[channelIndex].fieldList[fieldIndex].name);
                                                    }


                                                });
                                        })(channelIndex);
                                    }
                                }
                            }, 15000);
                        }
                    }
                }*/
            },
            colors: ['#D62021', '#00AAFF', '#AFAF00', '#f7a35c', '#8085e9', 
   					'#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
            rangeSelector: {
                /*buttons: [{
                    count: 12,
                    type: 'hour',
                    text: '12h'
                }, {
                    count: 1,
                    type: 'day',
                    text: 'D'
                }, {
                    count: 1,
                    type: 'week',
                    text: 'W'
                }/*, {
                    count: 1,
                    type: 'month',
                    text: 'M'
                }, {
                    count: 1,
                    type: 'year',
                    text: 'Y'
                }, {
                    type: 'all',
                    text: 'All'
                }*///],
                enabled: false
               // selected: 1 //Change to 4th button as default
            },
            plotOptions: {
                line: {
                    gapSize: 1
                        //color: '#d62020'
                        //  },
                        //  bar: {
                        //color: '#d52020'
                        //  },
                        //  column: {
                },
                series: {
                    marker: {
                        enabled: true,
                        radius: 4
                    },
                    animation: true,
                    step: false,
                    turboThrehold: 0,
                    borderWidth: 0,
                    lineWidth: 3
                }
            },
            tooltip: {
                shared: true,
                valueDecimals: 1// ,
//                 
//                 pointFormatter: function() {
//        				 var seriesNameConverter = {
//            			 'Wind Speed[km/h]': 'Series One Name',
//            			 'Wind Speed Gust[km/h]': 'Series Two Name'
//       				  };
// 
//         		return '<span style="color:{point.color}">\u25CF</span> ' + seriesNameConverter[this.series.name] + ': <b>' + this.y + '</b><br/>';
//     			}		
            },
            title: {
                text: 'Windgeschwindigkeit & Böe',
                style: {
                  "fontSize":"25px",
                  "fontFamily":"Roboto"
                }
                
            },
            /*subtitle: {
                text: 'subt',
                style: {
                  "fontSize":"14px",
                  "fontFamily":"Roboto"
                }
            },*/
            xAxis: {
                type: 'datetime',
                ordinal: false,
                offset: 40,
               // min: Date.UTC(2018, 7, 5),
                dateTimeLabelFormats: {
                   minute: '%H:%M',
                   hour: '%H:%M',
                   day: '<b>%d. %b</b>'
                },
                labels:{
                style: {
                     fontSize:14
                    }
                }
              /*,
                title: {
                    text: ''
                }*/
            },
            yAxis: [{
                labels: {
                    formatter: function(){
                        if(getCookie(isKnoten) == "1"){
                    		return this.value + " Knoten";
                   		}
                    	else{
                    		return this.value + " km/h";
                    	}
                    },
                    style: {
                     fontSize:18
                    }
                },
                title: {
                    text: ''
                },
                opposite: false,
                id: 'km/h',
                showLastLabel:true
            }, {
                labels: {
                    format: '{value}°'
                },
                title: {
                    text: ''
                },
                opposite: true,
                id: '°',
                showLastLabel:true
            }],
            scrollbar: {
                enabled: false
            },
            exporting: {
                enabled: false,
                csv: {
                    dateFormat: '%d/%m/%Y %H:%M:%S %p'
                }
            },
            tooltip: {
        headerFormat: "",
        useHTML: true,
        formatter: function () {
        
            var s = '<span style="font-size: 15px">' + Highcharts.dateFormat('%H:%M:%S  - %a, %e %b, %Y', new Date(this.x)) + '</span>';

            $.each(this.points, function () {
            	if(this.series.name == "Böe Windrichtung"){
            	  //  s += '<br/><span style="font-size: 20px; color:' + this.color + '"><b>' + this. + '</b><br/></span>'; 

            	}
            	else if(this.series.name == "Böe"){
                	s += '<br/><span style="font-size: 20px; color:' + this.color + '"><b>' + Highcharts.numberFormat(this.y, 1) + " " + getWindspeedUnit() + " (Böe)" +'</b><br/></span>'; 
				}
            	else
                	s += '<br/><span style="font-size: 20px; color:' + this.color + '"><b>' + Highcharts.numberFormat(this.y, 1) + " " + getWindspeedUnit() + '</b><br/></span>'; 
            });

            return s;
        }
    },
            legend: {
                enabled: true,
                itemStyle: {
                //color: 'white',
                //fontWeight: 'bold',
                fontSize: '17px'
                }
            },
            navigator: {
                enabled: false,
                baseSeries: 0, //select which series to show in history navigator, First series is 0
                series: {
                    includeInCSVExport: false
                }
            },
            credits: {
                enabled: false
            },
            series: []
         
            
                //series: [{data:[[getChartDate("2013-06-16T00:32:40Z"),75]]}]
        };

		addChartSeriesData(chartOptions);

        // draw the chart
        dynamicChart = new Highcharts.StockChart(chartOptions);



        // update series number to account for the navigator series (The historical series at the bottom) which is the first series.
        for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeys[channelIndex].fieldList.length; fieldIndex++) // and each field
            {
                for (var seriesIndex = 0; seriesIndex < dynamicChart.series.length; seriesIndex++) // compare each series name
                {
                    if (dynamicChart.series[seriesIndex].name == channelKeys[channelIndex].fieldList[fieldIndex].name) {
                        channelKeys[channelIndex].fieldList[fieldIndex].series = seriesIndex;
                    }
                }
            }
        }
        
        
        // add all history
        //dynamicChart.showLoading("Loading History..." );
        window.console && console.log('Channels: ', channelKeys.length);
        for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
        {
            window.console && console.log('channelIndex: ', channelIndex);
            (function(channelIndex) {
                //load only 1 set of 8000 points
                //loadChannelHistory(channelIndex, channelKeys[channelIndex].channelNumber, channelKeys[channelIndex].key, channelKeys[channelIndex].fieldList, 0, 1);
            })(channelIndex);
        }
    }


function createChartTemp() {
  	window.console && console.log('CREATE CHART TEMP');

        // specify the chart options
        var chartOptionsTemp = {
            chart: {
                renderTo: 'chartTemp-container',
                zoomType: 'x'
            },
            colors: ['#AFAF00', '#00AAFF', '#D62021', '#f7a35c', '#8085e9', 
   					'#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
            rangeSelector: {

                enabled: false
               // selected: 1 //Change to 4th button as default
            },
            plotOptions: {
                line: {
                    gapSize: 1
                },
                series: {
                    marker: {
                        enabled: true,
                        radius: 4
                    },
                    animation: true,
                    step: false,
                    turboThrehold: 0,
                    borderWidth: 0,
					lineWidth: 3

                }
            },
            tooltip: {
                shared: true,
                valueDecimals: 1// ,
	
            },
            title: {
                text: 'Temperatur & Luftdruck',
                style: {
                  "fontSize":"25px",
                  "fontFamily":"Roboto"
                }
                
            },

            xAxis: {
                type: 'datetime',	
                ordinal: false,
                offset: 0,
               // min: Date.UTC(2018, 7, 5),
                dateTimeLabelFormats: {
                   minute: '%H:%M',
                   hour: '%H:%M',
                   day: '<b>%d. %b</b>'
                },
                labels:{
                style: {
                     fontSize:14
                    }
                }

            },
            yAxis: [{
                labels: {
                    format: '{value}°C',
                    style: {
                     color: '#AFAF00',
                     fontSize:18
                    }
                },
                title: {
                    text: ''
                },
                opposite: false,
                id: '°C',
                showLastLabel:true
            }, {
                labels: {
                    format: '{value}hPa',
                    style: {
                     color: '#00AAFF',
                     fontSize:18
                    }
                },
                title: {
                    text: ''
                },
                opposite: true,
                id: 'hPa',
                showLastLabel:true
            }/*,{
                labels: {
                    format: '{value}hPa'
                },
                title: {
                    text: ''
                },
                opposite: true,
                id: 'hPa'
            }*/],
            scrollbar: {
                enabled: false
            },
            exporting: {
                enabled: false,
                csv: {
                    dateFormat: '%d/%m/%Y %H:%M:%S %p'
                }
            },
            tooltip: {
        headerFormat: "",
        useHTML: true,
        formatter: function () {
        
        
            var s = '<span style="font-size: 15px">' + Highcharts.dateFormat('%H:%M:%S  - %a, %e %b, %Y', new Date(this.x)) + '</span>';

            $.each(this.points, function () {
            	if(this.series.name == "Temperatur"){
					s += '<br/><span style="font-size: 22px; color:' + this.color + '"><b>' + Highcharts.numberFormat(this.y, 1) + "°C " +'</b><br/></span>'; 

            	}
            	else
					s += '<br/><span style="font-size: 22px; color:' + this.color + '"><b>' + Highcharts.numberFormat(this.y, 1) + "hPa " +'</b><br/></span>'; 
            });

            return s;
        }
    },
            legend: {
                enabled: true,
                itemStyle: {
                //color: 'white',
                //fontWeight: 'bold',
                fontSize: '17px'
            }
            },
            navigator: {
                enabled: false,
                baseSeries: 0, //select which series to show in history navigator, First series is 0
                series: {
                    includeInCSVExport: false
                }
            },
            credits: {
                enabled: false
            },
            series: []
         
            
                //series: [{data:[[getChartDate("2013-06-16T00:32:40Z"),75]]}]
        };

		addChartSeriesDataTemp(chartOptionsTemp);

        window.console && console.log('create dynchart ');

        // draw the chart
        dynamicChartTemp = new Highcharts.StockChart(chartOptionsTemp);

		window.console && console.log('after create dynchart ');

                // update series number to account for the navigator series (The historical series at the bottom) which is the first series.
        for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeysTemp[channelIndex].fieldList.length; fieldIndex++) // and each field
            {
                for (var seriesIndex = 0; seriesIndex < dynamicChartTemp.series.length; seriesIndex++) // compare each series name
                {
                    if (dynamicChartTemp.series[seriesIndex].name == channelKeysTemp[channelIndex].fieldList[fieldIndex].name) {
                      //  channelKeysTemp[channelIndex].fieldList[fieldIndex].series = seriesIndex;
                    }
                }
            }
        }
        
        // add all history
        //dynamicChart.showLoading("Loading History..." );
        window.console && console.log('Channels: ', channelKeysTemp.length);
        for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
        {
            window.console && console.log('channelIndex: ', channelIndex);
            (function(channelIndex) {
                //load only 1 set of 8000 points
                //loadChannelHistory(channelIndex, channelKeys[channelIndex].channelNumber, channelKeys[channelIndex].key, channelKeys[channelIndex].fieldList, 0, 1);
            })(channelIndex);
        }
    }


function createChartDebug() {
  	window.console && console.log('CREATE CHART DEBUG');

        // specify the chart options
        var chartOptionsDebug = {
            chart: {
                renderTo: 'chartDebug-container',
                zoomType: 'x'
            },
            colors: ['#AFAF00', '#00AAFF', '#D62021', '#f7a35c', '#8085e9', 
   					'#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
            rangeSelector: {

                enabled: false
               // selected: 1 //Change to 4th button as default
            },
            plotOptions: {
                line: {
                    gapSize: 1
                },
                series: {
                    marker: {
                        enabled: true,
                        radius: 4
                    },
                    animation: true,
                    step: false,
                    turboThrehold: 0,
                    borderWidth: 0,
					lineWidth: 3

                }
            },
            tooltip: {
                shared: true,
                valueDecimals: 1// ,
	
            },
            title: {
                text: 'Akku Ladestatus & Lichtstärke',
                style: {
                  "fontSize":"25px",
                  "fontFamily":"Roboto"
                }
                
            },

            xAxis: {
                type: 'datetime',	
                ordinal: false,
                offset: 0,
               // min: Date.UTC(2018, 7, 5),
                dateTimeLabelFormats: {
                   minute: '%H:%M',
                   hour: '%H:%M',
                   day: '<b>%d. %b</b>'
                },
                labels:{
                style: {
                     fontSize:14
                    }
                }

            },
            yAxis: [{
                labels: {
                    format: '{value}%',
                    style: {
                     color: '#AFAF00',
                     fontSize:18
                    }
                },
                title: {
                    text: ''
                },
                opposite: false,
                id: '%',
                floor: 0,
                allowDecimals: true,
                ceiling: 100.0,
                max: 100,
                endOnTick: true,
                min: 0,
                showLastLabel:true,
                alignTicks:true,
            }, {
                labels: {
                    format: '{value}',
                    style: {
                     color: '#00AAFF',
                     fontSize:18
                    }
                },
                title: {
                    text: ''
                },
                opposite: true,
                id: 'akku',
                floor: 0,
                alignTicks:true,
                allowDecimals: false,
                ceiling: 4,
                max: 4,
                min:0,
                endOnTick: true,
                showLastLabel:false
               // min: 0
            }/*,{
                labels: {
                    format: '{value}hPa'
                },
                title: {
                    text: ''
                },
                opposite: true,
                id: 'hPa'
            }*/],
            scrollbar: {
                enabled: false
            },
            exporting: {
                enabled: false,
                csv: {
                    dateFormat: '%d/%m/%Y %H:%M:%S %p'
                }
            },
            tooltip: {
        headerFormat: "",
        useHTML: true,
        formatter: function () {
        
        
            var s = '<span style="font-size: 15px">' + Highcharts.dateFormat('%H:%M:%S  - %a, %e %b, %Y', new Date(this.x)) + '</span>';

            $.each(this.points, function () {
            	if(this.series.name == "Lichtstärke"){
					s += '<br/><span style="font-size: 22px; color:' + this.color + '"><b>' + Highcharts.numberFormat(this.y, 0) + "% " +'</b><br/></span>'; 
            	}
            	else
					s += '<br/><span style="font-size: 22px; color:' + this.color + '"><b>' + Highcharts.numberFormat(this.y, 1) +'</b><br/></span>'; 
            });

            return s;
        }
    },
            legend: {
                enabled: true,
                itemStyle: {
                //color: 'white',
                //fontWeight: 'bold',
                fontSize: '17px'
            }
            },
            navigator: {
                enabled: false,
                baseSeries: 0, //select which series to show in history navigator, First series is 0
                series: {
                    includeInCSVExport: false
                }
            },
            credits: {
                enabled: false
            },
            series: []
         
            
                //series: [{data:[[getChartDate("2013-06-16T00:32:40Z"),75]]}]
        };

		addChartSeriesDataDebug(chartOptionsDebug);

        // draw the chart
        dynamicChartDebug = new Highcharts.StockChart(chartOptionsDebug);


                // update series number to account for the navigator series (The historical series at the bottom) which is the first series.
        for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
        {
            for (var fieldIndex = 0; fieldIndex < channelKeysDebug[channelIndex].fieldList.length; fieldIndex++) // and each field
            {
                for (var seriesIndex = 0; seriesIndex < channelKeysDebug.series.length; seriesIndex++) // compare each series name
                {
                    if (dynamicChartDebug.series[seriesIndex].name == channelKeysDebug[channelIndex].fieldList[fieldIndex].name) {
                      //  channelKeysTemp[channelIndex].fieldList[fieldIndex].series = seriesIndex;
                    }
                }
            }
        }
        
        // add all history
        //dynamicChart.showLoading("Loading History..." );
        window.console && console.log('Channels: ', channelKeysDebug.length);
        for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
        {
            window.console && console.log('channelIndex: ', channelIndex);
            (function(channelIndex) {
                //load only 1 set of 8000 points
                //loadChannelHistory(channelIndex, channelKeys[channelIndex].channelNumber, channelKeys[channelIndex].key, channelKeys[channelIndex].fieldList, 0, 1);
            })(channelIndex);
        }
    }


//

//  This is where the chart is generated.
$(document).ready(function() {

	window.console && console.log('READY');

    $('select').material_select();
    //Add Channel Load Menu
    //var menu = document.getElementById("Channel Select");
    //for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
    //{
    //    window.console && console.log('Name', channelKeys[channelIndex].name);
    //    var menuOption = new Option(channelKeys[channelIndex].name, channelIndex);
    //    menu.options.add(menuOption, channelIndex);
    //}
    var last_date; // variable for the last date added to the chart
    //window.console && console.log('Testing console');
    //make series numbers for each field
    var seriesCounter = 0
    for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
    {
        for (var fieldIndex = 0; fieldIndex < channelKeys[channelIndex].fieldList.length; fieldIndex++) // iterate through each channel
        {
            channelKeys[channelIndex].fieldList[fieldIndex].series = seriesCounter;
            seriesCounter++;
        }
    }
    var seriesCounterTemp = 0
    for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
    {
        for (var fieldIndex = 0; fieldIndex < channelKeysTemp[channelIndex].fieldList.length; fieldIndex++) // iterate through each channel
        {
            channelKeysTemp[channelIndex].fieldList[fieldIndex].series = seriesCounterTemp;
            seriesCounterTemp++;
        }
    }
        var seriesCounterDebug = 0
    for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
    {
        for (var fieldIndex = 0; fieldIndex < channelKeysDebug[channelIndex].fieldList.length; fieldIndex++) // iterate through each channel
        {
            channelKeysDebug[channelIndex].fieldList[fieldIndex].series = seriesCounterDebug;
            seriesCounterDebug++;
        }
    }
    //make calls to load data from each channel into channelKeys array now
    // draw the chart when all the data arrives, later asyncronously add history
    for (var channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) // iterate through each channel
    {

        channelKeys[channelIndex].loaded = false;
        loadThingSpeakChannel(channelIndex, channelKeys[channelIndex].channelNumber, channelKeys[channelIndex].key, channelKeys[channelIndex].fieldList, true, false, false);
    }
    for (var channelIndex = 0; channelIndex < channelKeysTemp.length; channelIndex++) // iterate through each channel
    {

        channelKeysTemp[channelIndex].loaded = false;
        loadThingSpeakChannel(channelIndex, channelKeysTemp[channelIndex].channelNumber, channelKeysTemp[channelIndex].key, channelKeysTemp[channelIndex].fieldList, true, true, false);
    }
    for (var channelIndex = 0; channelIndex < channelKeysDebug.length; channelIndex++) // iterate through each channel
    {
        channelKeysDebug[channelIndex].loaded = false;
        loadThingSpeakChannel(channelIndex, channelKeysDebug[channelIndex].channelNumber, channelKeysDebug[channelIndex].key, channelKeysDebug[channelIndex].fieldList, true, false, true);

    }
    //window.console && console.log('Channel Keys',channelKeys);

});



/*function loadOneChannel() {
    // load a channel selected in the popUp menu.
    var selectedChannel = document.getElementById("Channel Select");
    var maxLoads = document.getElementById("Loads").value;
    var channelIndex = selectedChannel.selectedIndex;
  //  loadChannelHistory(channelIndex, channelKeys[channelIndex].channelNumber, channelKeys[channelIndex].key, channelKeys[channelIndex].fieldList, 0, maxLoads);
}*/

// load next 8000 points from a ThingSpeak channel and addPoints to a series
/*function loadChannelHistory(sentChannelIndex, channelNumber, key, sentFieldList, sentNumLoads, maxLoads) {
    var numLoads = sentNumLoads
    var fieldList = sentFieldList;
    var channelIndex = sentChannelIndex;
    var first_Date = new Date();
    if (typeof fieldList[0].data[0] != "undefined") first_Date.setTime(fieldList[0].data[0][0] + 7 * 60 * 60 * 1000); //adjust for 7 hour difference from GMT (Zulu time)
    else if (typeof fieldList[1].data[0] != "undefined") first_Date.setTime(fieldList[1].data[0][0] + 7 * 60 * 60 * 1000);
    else if (typeof fieldList[2].data[0] != "undefined") first_Date.setTime(fieldList[2].data[0][0] + 7 * 60 * 60 * 1000);
    else if (typeof fieldList[3].data[0] != "undefined") first_Date.setTime(fieldList[3].data[0][0] + 7 * 60 * 60 * 1000);
    else if (typeof fieldList[4].data[0] != "undefined") first_Date.setTime(fieldList[4].data[0][0] + 7 * 60 * 60 * 1000);
    else if (typeof fieldList[5].data[0] != "undefined") first_Date.setTime(fieldList[5].data[0][0] + 7 * 60 * 60 * 1000);
    else if (typeof fieldList[6].data[0] != "undefined") first_Date.setTime(fieldList[6].data[0][0] + 7 * 60 * 60 * 1000);
    else if (typeof fieldList[7].data[0] != "undefined") first_Date.setTime(fieldList[7].data[0][0] + 7 * 60 * 60 * 1000);
    var end = first_Date.toJSON();
    window.console && console.log('earliest date:', end);
    window.console && console.log('sentChannelIndex:', sentChannelIndex);
    window.console && console.log('numLoads:', numLoads);
    // get the Channel data with a webservice call
    $.getJSON('https://www.thingspeak.com/channels/' + channelNumber + '/feed.json?callback=?&amp;offset=0&amp;start=2013-01-20T00:00:00;end=' + end + ';key=' + key, function(data) {
        // if no access
        if (data == '-1') {
            $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
            window.console && console.log('Thingspeak Data Loading Error');
        }
        for (var fieldIndex = 0; fieldIndex < fieldList.length; fieldIndex++) // iterate through each field
        {
            //fieldList[fieldIndex].data =[];
            for (var h = 0; h < data.feeds.length; h++) // iterate through each feed (data point)
            {
                var p = [] //new Highcharts.Point();
                var fieldStr = "data.feeds[" + h + "].field" + fieldList[fieldIndex].field;
                var v = eval(fieldStr);
                p[0] = getChartDate(data.feeds[h].created_at);
                p[1] = parseFloat(v);
                // if a numerical value exists add it
                if (!isNaN(parseInt(v))) {
                    fieldList[fieldIndex].data.push(p);
                }
            }
            fieldList[fieldIndex].data.sort(function(a, b) {
                return a[0] - b[0]
            });
            dynamicChart.series[fieldList[fieldIndex].series].setData(fieldList[fieldIndex].data, false);
            //dynamicChart.series[fieldList[fieldIndex].series].addPoint(fieldList[fieldIndex].data,false);
            //fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
            //window.console && console.log('data added to series:',fieldList[fieldIndex].series,fieldList[fieldIndex].data);
        }
        channelKeys[channelIndex].fieldList = fieldList;
        dynamicChart.redraw()
        window.console && console.log('channel index:', channelIndex);
        numLoads++;
        if (numLoads < maxLoads) {
            loadChannelHistory(channelIndex, channelNumber, key, fieldList, numLoads, maxLoads);
        }
    });
}*/

//# sourceURL=pen.js
</script>
</body></html>
